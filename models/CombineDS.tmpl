/* 
 *  models/CombineDS.tmpl
 *
 *  Copyright (C) 2020-2021 Viktor Senderov and TODO paper authors
 *
 *  Templated file: $vars need to be replaced by actual values.
 *  with ./compile_template.sh
 *  
 *     __(1)__ - tree
 *     __(2)__ - rho
 *     __(3)__ - lamdba0 shape
 *     __(4)__ - lambda0 scale
 *     __(5)__ - mu0 shape
 *     __(6)__ - mu0 scale
 *     __(7)__ - nu0 scape
 *     __(8)__ - nu0 scale
 *     __(9)__ - alpha, sigma (clads) - m0 
 *     __(10)__ - alpha, sigma (clads) - v 
 *     __(11)__ - alpha, sigma (clads) - a
 *     __(12)__ - alpha, sigma (clads) - b 
 *     __(13)__ - alpha, sigma (anads) - m0
 *     __(14)__ - alpha, sigma (anads) - v
 *     __(15)__ - alpha, sigma (anads) - a
 *     __(16)__ - alpha, sigma (anads) - b
 *     __(17)__ - clads (true/false)
 *     __(18)__ - extinction level (0 - none, 1 - const, 2 - turnover const)
 *     __(19)__ - anads (stochastic) level (0 - none, 1 - const, 2 - turnover to lambda const)
 *     __(20)__ - step size for AnaDS-GBM
 *     __(21)__ - maximum recursion depth allowed in side-branch simulations
 *
 *  CombineDS diversification model sconditionally simulates several
 *  different types of evolution:
 *
 *    - cladogenetic (ClaDS-like) changes in diversification
 *      rates, ClaDS versions 0-2. TODO version 0
 *	      
 *    - stochastic anagenetic (AnaDS) happening on a single lineage (used for rare shifts)
 * 
 *    - AnaDS with a constant step size (approxiamtion of generalized Brownian motion, AnaDS-GBM)
 * 
 *  Priors need to be set in PSTATE via the initialize macro. See
 *  progState_t for details.
 * 
 *  Tunable parameters:
 *
 *    #define CLADS false             // Cladogenetic changes
 *    #define ANADS 2                 // NEW
 *    #define EXTINCTION 2            // 2 - constant turnover, 1 - const, 0 - no exticntion
 *    #define STEP_SIZE 1             // AnaDS-GBM step size in Mya
 *
 * Not tunable! (unless you know)
 *
 *    #define M 20                         // Number of subsamples to draw
 *    #define DEBUG false                  // debugging output
 *    #define GUARD true
 *    #define MAX_FACTOR 1e5 
 *    #define MAX_DEPTH 10      // maximum recursion depth allowed
 *
 *  Tree selection, 4 steps:
 *
 *    #include "trees/cetaceans.cuh"       // (1)
 *    typedef cetaceans_87_tree_t tree_t;  // (2)
 *    BBLOCK_DATA(tree, tree_t, 1)         // 3
 *    BBLOCK_DATA_CONST(rho, floating_t, 1.0) // rate (4)
 *
 *  models/CombineDS.cuh defines the following BBLOCKS that can be included
 *  in the MAIN macro:
 *
 *    - initialization        (required), see progstate
 *
 *    - simCombinedDS         (required)
 *
 *    - simTree               (required)
 *
 *    - conditionOnDetection  (optional, corrects for survivorship bias) TODO
 *
 *    - sampleFinalLambda     (optional, samples the global parameters,
 *                             which have been delayed)
 *
 *    - saveResults           (optional callback, needs to be used in 
 *                             conjunction with sampleFinalLambda)
 * 
 *  TODOs:
 *    - RareDS
 *    - Count number of anagenetic and cladogenetic shifts (an anagenetic shift,
 *       if it is the last one before a hidden or seen speciation event is considered
 *       a cladogenetic change
 *    - Posteriors outputs and importance sampling & visualization
 *    - Bias corrections
 */

#include <iostream>
#include <cstring>
#include <cassert>
#include <string>
#include <fstream>
#include <algorithm>
#include <random>

#include "inference/smc/smc.cuh"
#include "trees/tree_utils.cuh"
#include "utils/math.cuh"
#include "utils/stack.cuh"
#include "dists/delayed.cuh"
#include "trees/cetaceans.cuh"
#include "trees/birds.cuh"
#include "trees/default_trees.cuh"

#define CLADS __(17)__              // Cladogenetic changes
#define ANADS __(19)__                // Anagenetic changes
#define EXTINCTION __(18)__             // 2 - constant turnover, 1 - const, 0 - no exticntion
#define STEP_SIZE __(20)__

#define RARE_SHIFT false         // RARE_DS model TODO
#define RESAMPLE_RATES false     // TODO resample turnover and anagenesis rate at rate shifts

/* Do not tune unless you know what you're doing! */
#define GUARD true
#define NICOLAS false
#define MAX_FACTOR 1e5 
#define MIN_FACTOR std::numeric_limits<float>::denorm_min()
#define MAX_DEPTH __(21)__
#define PRECISION 10e-5    // used to avoid rounding error pitfalls ~ 1 year
#define M 20              // Number of subsamples to draw
#define DEBUG false
unsigned int depth;

const std::string analysisName = "CombineDS";

typedef __(1)___tree_t tree_t;
BBLOCK_DATA(tree, tree_t, 1)
BBLOCK_DATA_CONST(rho, floating_t, __(2)__)
BBLOCK_DATA_CONST(stepSize, floating_t, STEP_SIZE)

typedef short treeIdx_t;

struct progState_t {
  treeIdx_t treeIdx;

  // Priors, need to be initialized manually 
  gamma_t lambda_0;
  gamma_t mu_0;
  gamma_t nu_0;
  normalInverseGamma_t alpha_sigma;
  normalInverseGamma_t alpha_sigma_nu; // for anads

  //Posterior samples
  floating_t lambda0;
  floating_t mu0;
  floating_t nu0;
  floating_t alpha;
  floating_t sigma;
  floating_t alpha_nu; // for anads
  floating_t sigma_nu; // for anads

//  floating_t epsilon;
//  floating_t ypsilon;
  
  floating_t factors[(tree->NUM_NODES)]; // first is 1, all other 0 for now
  // TODO
  // Technically we don't need a factor for the root (it is assumed to be 1)
  // But for now we are going to waste one posistion for easier debugging.
  
  int numberShifts_ClaDS;
  int numberShifts_AnaDS;  
};

INIT_MODEL(progState_t)



/*
 * getBrownianTime
 *
 * floating_t - the time difference until the next brownian event,
 * 
 * floating_t currentTime - time from which we count.
 *
 * The tree age and the step size will be taken from the global state.
 */

BBLOCK_HELPER(getBrownianTime,
{
  tree_t* treeP = DATA_POINTER(tree);
  floating_t treeAge = treeP->ages[ROOT_IDX];
  floating_t elapsedTime = treeAge - currentTime;
  if (abs(elapsedTime) < PRECISION) // we are too close to the root
  {
      return DATA_CONST(stepSize);
  }
  int nextStep = ceil(elapsedTime / (floating_t) DATA_CONST(stepSize));
  floating_t nextStepTime = treeAge - nextStep * DATA_CONST(stepSize);
  floating_t dt = currentTime - nextStepTime;
  return dt;
  
 }, floating_t, floating_t currentTime)

  

/*
 
 * goesUndetected - helper function
 *
 *            bool,
 *            floating_t startTime -- current time at which we investigate,

 *	      floating_t factor,
 *            int depth
 */
BBLOCK_HELPER(goesUndetected,
{
  if (GUARD) {
    if (factor > MAX_FACTOR || depth > MAX_DEPTH) {
      return false; 
    }
    if (factor < MIN_FACTOR) {
      return false;
    } 
  }

  floating_t waitingTime_brownian = BBLOCK_CALL(getBrownianTime, startTime);
  floating_t waitingTime_speciation = SAMPLE(sample_GammaExponential, PSTATE.lambda_0, factor);
  floating_t waitingTime_extinction = INFINITY; // case 0

  switch(EXTINCTION) {
  case 1:
    waitingTime_extinction = SAMPLE(sample_GammaExponential, PSTATE.mu_0, 1.0);
    break;
  case 2:
    waitingTime_extinction = SAMPLE(sample_GammaExponential, PSTATE.mu_0, factor); 
  }

  floating_t waitingTime_anagenesis =  INFINITY; // case 0
  switch(ANADS) {
  case 1:
    waitingTime_anagenesis =   SAMPLE(sample_GammaExponential, PSTATE.nu_0, 1.0);
    break;
  case 2:
    waitingTime_anagenesis =   SAMPLE(sample_GammaExponential, PSTATE.nu_0, factor);
  } 
  
  if (DEBUG) printf( "%f %f  %f %f %f %f %d\n", waitingTime_brownian, startTime, factor, waitingTime_speciation,  waitingTime_extinction, waitingTime_anagenesis, depth);
  
  floating_t t                      = MIN(waitingTime_speciation, waitingTime_extinction);
  
  if (waitingTime_brownian < t && waitingTime_brownian < waitingTime_anagenesis) {
    // handle brownian case
    floating_t currentTime = startTime - waitingTime_brownian - PRECISION; // advance a little bit in the future as not to land
                                                                           // in the same spot when recurring 
    if (currentTime < 0) {
      bool undetected = !SAMPLE(bernoulli, DATA_CONST(rho));
      return undetected;
    }
    
    floating_t f1 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma_nu);
    return BBLOCK_CALL(goesUndetected, currentTime, factor*exp(f1), depth + 1);
  }
  
  if (t < waitingTime_anagenesis) { // cladogenetic or CRBD case
    floating_t currentTime = startTime - t;
    
    if (currentTime < 0) { // we are in the future, rho is the detection probability
      bool undetected = !SAMPLE(bernoulli, DATA_CONST(rho));
      return undetected;
    }
    
    bool speciation =  (waitingTime_speciation < waitingTime_extinction) ? true : false;
    bool extinction = !speciation;
    if(extinction) {
      return true;
    }
    
    // Speciation
    // CRBD case
    floating_t fMin = 0.0;
    floating_t fMax = 0.0;
    
    if (CLADS) { // cladogenetic change
      floating_t f1 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma);
      floating_t f2 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma);
      if (NICOLAS) {
	fMin = MIN(f1, f2);
	fMax = MAX(f1, f2);
	assert(fMin <= fMax);
      }
      else {
      	fMin = f1;
      	fMax = f2;
      }
    }
    
    bool leftDetection = ! BBLOCK_CALL(goesUndetected, currentTime, factor*exp(fMin), depth + 1);
    if (leftDetection) return false; // no need to descend to the right side of the tree
    return BBLOCK_CALL(goesUndetected, currentTime, factor*exp(fMax),  depth + 1);
  }
  else { // anagenesis
    floating_t currentTime = startTime - waitingTime_anagenesis;
    if (currentTime <0 ) {
      bool undetected = !SAMPLE(bernoulli, DATA_CONST(rho));
      return undetected;
    }
    
    floating_t f1 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma_nu);
    return BBLOCK_CALL(goesUndetected, currentTime, factor*exp(f1), depth + 1);
  }
 },
	      bool,
	      floating_t startTime,
	      floating_t factor,
	      int depth)






/* 
 * simBranchReturn_t - return type
 *
 *   - floating_t factorEnd  the accumulated factors along the branch
 *   - floating_t prob       the accumulated probability along the branch
 */
struct simBranchReturn_t {
  floating_t factorEnd;
  floating_t prob;

  DEV simBranchReturn_t(){};
  
  DEV simBranchReturn_t(floating_t factorEnd_, floating_t prob_) {
    factorEnd = factorEnd_;
    prob = prob_;
  }
};



/* 
 * TODO this one will have to count cladogenetic vs anagenetic shifts
 * see slack message on how to do it
 * simBranch - helper to simTree
 * 
 *  - has side-effects on arguments
 *
 */
BBLOCK_HELPER(simBranch,
{ 		   
  if(GUARD) {
    if (factor > MAX_FACTOR) {
      simBranchReturn_t ret(MAX_FACTOR, -INFINITY);
      return ret;  
    }
    if (factor < MIN_FACTOR) {
      simBranchReturn_t ret(MIN_FACTOR, -INFINITY);
      return ret;
    }
  }

  floating_t branchLengthTime = startTime - stopTime;  
  floating_t tCladogenetic = SAMPLE(sample_GammaExponential, PSTATE.lambda_0, factor);
  floating_t tBrownian = BBLOCK_CALL(getBrownianTime, startTime);
  floating_t tAnagenetic =  INFINITY; // case 0

  switch(ANADS) {
  case 1:
    tAnagenetic =   SAMPLE(sample_GammaExponential, PSTATE.nu_0, 1.0);
    break;
  case 2:
    tAnagenetic =   SAMPLE(sample_GammaExponential, PSTATE.nu_0, factor);
  } 
  
  floating_t t = MIN(tAnagenetic, tCladogenetic);

  if (tBrownian < t && tBrownian < tAnagenetic) {
    floating_t currentTime = startTime - tBrownian - PRECISION;
    
    if(currentTime <= stopTime) {
      simBranchReturn_t ret(factor, 0); // case 0
      switch (EXTINCTION) {
      case 1:
	ret.prob = score_GammaPoisson(0, branchLengthTime, PSTATE.mu_0, 1.0);
	break;
      case 2:
	ret.prob = score_GammaPoisson(0, branchLengthTime, PSTATE.mu_0, factor);
      }
      return ret;
    }

    floating_t f1 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma_nu);
  
    floating_t extinctionProb = 0; // case 0
    switch (EXTINCTION) {
      case 1:
	extinctionProb = score_GammaPoisson(0, t, PSTATE.mu_0, 1.0);
	break;
      case 2:
	extinctionProb = score_GammaPoisson(0, t, PSTATE.mu_0, factor);
      }
    
    simBranchReturn_t ret2 = BBLOCK_CALL(simBranch, currentTime, stopTime,  factor*exp(f1));
    
    // Now gather all weights and add 2 for the end of the branch
    // we are not at branch end, so no need to add 2!!!!
    simBranchReturn_t ret(ret2.factorEnd, ret2.prob + extinctionProb);
    return ret;
  }
  
  if (tCladogenetic < tAnagenetic) { //Cladogenetic or CRBD case
    floating_t currentTime = startTime - t;
    
    if(currentTime <= stopTime) {
      simBranchReturn_t ret(factor, 0); // case 0
      switch (EXTINCTION) {
      case 1:
	ret.prob = score_GammaPoisson(0, branchLengthTime, PSTATE.mu_0, 1.0);
	break;
      case 2:
	ret.prob = score_GammaPoisson(0, branchLengthTime, PSTATE.mu_0, factor);
      }
      return ret;
    }
    
    // hidden speciation event CRBD case
    floating_t f1 = 0.0;
    floating_t f2 = 0.0;
    
    if (CLADS) {
      // TODO count shifts, also in AnaDS case
      f1 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma);
      f2 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma);
      // cannot swap here
    }
    
    bool sideUndetected = BBLOCK_CALL(goesUndetected, currentTime, factor*exp(f1), 0);
    if(!sideUndetected) {
      simBranchReturn_t ret(factor, -INFINITY);
      return ret;
    }

    simBranchReturn_t ret2 = BBLOCK_CALL(simBranch, currentTime, stopTime,  factor*exp(f2));
    
    floating_t extinctionProb = 0; // case 0
    switch (EXTINCTION) {
    case 1:
      extinctionProb = score_GammaPoisson(0, t, PSTATE.mu_0, 1.0);
      break;
    case 2:
      extinctionProb = score_GammaPoisson(0, t, PSTATE.mu_0, factor);
    }

    simBranchReturn_t ret(ret2.factorEnd, ret2.prob + log(2.0) + extinctionProb);
    return ret;
  }
  else { // Anagenetic shift
    floating_t currentTime = startTime - t;
    
    if(currentTime <= stopTime) {
      simBranchReturn_t ret(factor, 0);
      switch (EXTINCTION) {
      case 1:
	ret.prob = score_GammaPoisson(0, branchLengthTime, PSTATE.mu_0, 1.0);
	break;
      case 2:
	ret.prob = score_GammaPoisson(0, branchLengthTime, PSTATE.mu_0, factor);
      }
      return ret;
    }

    floating_t f1 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma_nu);
  
    floating_t extinctionProb = 0;
    switch (EXTINCTION) {
      case 1:
	extinctionProb = score_GammaPoisson(0, t, PSTATE.mu_0, 1.0);
	break;
      case 2:
	extinctionProb = score_GammaPoisson(0, t, PSTATE.mu_0, factor);
      }
    
    simBranchReturn_t ret2 = BBLOCK_CALL(simBranch, currentTime, stopTime,  factor*exp(f1));
    
    // Now gather all weights and add 2 for the end of the branch
    // we are not at branch end, so no need to add 2!!!!
    simBranchReturn_t ret(ret2.factorEnd, ret2.prob + extinctionProb);
    return ret;
  }

},
	      simBranchReturn_t,
	      floating_t startTime,
	      floating_t stopTime,
	      floating_t factor);


BBLOCK(sampleFinalLambda, {
    PSTATE.lambda0 = SAMPLE(gamma, PSTATE.lambda_0.k, PSTATE.lambda_0.theta);
    PSTATE.mu0 = SAMPLE(gamma, PSTATE.mu_0.k, PSTATE.mu_0.theta);
    PSTATE.nu0 = SAMPLE(gamma, PSTATE.nu_0.k, PSTATE.nu_0.theta);
    // alpha_sigma - struct with fields m0, v, a, b
    // gamma - shape k and scale theta
    // alpha_sigma = NormalInverseGamma(0, 1.0, 1.0, 0.2)
    floating_t sigmaSquared = 1.0 / (SAMPLE(gamma, PSTATE.alpha_sigma.a, 1.0 / PSTATE.alpha_sigma.b));
    PSTATE.sigma = sigmaSquared; // sigma is actually sigma2
    PSTATE.alpha = exp(SAMPLE(normal, PSTATE.alpha_sigma.m0, PSTATE.sigma/PSTATE.alpha_sigma.v));

    floating_t sigmaSquared_nu = 1.0 / SAMPLE(gamma, PSTATE.alpha_sigma_nu.a, 1.0 / PSTATE.alpha_sigma_nu.b);
    PSTATE.sigma_nu = sqrt(sigmaSquared_nu);
    PSTATE.alpha_nu = exp(SAMPLE(normal, PSTATE.alpha_sigma_nu.m0, PSTATE.sigma_nu/PSTATE.alpha_sigma_nu.v ));

    NEXT = NULL;
})


// Should be equivalent to forward sampling
BBLOCK(conditionOnDetection, {
    tree_t* treeP = DATA_POINTER(tree);
    floating_t treeAge = treeP->ages[ROOT_IDX];

    int numSamples = 100;
    int numDetected = 0;
    for(int i = 0; i < numSamples; i++) {
      bool undetected = BBLOCK_CALL(goesUndetected, treeAge, 1.0, 0.0);
        if(! undetected)
            numDetected++;
    }
    WEIGHT(-2.0 * log(numDetected / static_cast<floating_t>(numSamples)));
    NEXT = sampleFinalLambda; // this was a probabilistic simulation, so resampling is needed
    //BBLOCK_CALL(NEXT, NULL);
})


/*
 * simTree - required
 */
BBLOCK(simTree,
{
  tree_t* treeP = DATA_POINTER(tree);
  treeIdx_t treeIdx = PSTATE.treeIdx; // During first invocation it goes left from root
  int indexParent = treeP->idxParent[treeIdx];

  if (DEBUG) {
    printf("Processing node %d\n", PSTATE.treeIdx);
  }
  
  // Terminate if tree is fully traversed
  if(treeIdx == -1) {
    //NEXT = NULL;
    NEXT = conditionOnDetection; // no resampling needed here, tree has been traversed
    BBLOCK_CALL(NEXT, NULL);
    return;
  }
  
  PSTATE.treeIdx = treeP->idxNext[treeIdx]; // advance
  
  // Branch simulation
  simBranchReturn_t ret =
      BBLOCK_CALL(simBranch,
		  treeP->ages[indexParent], // parent age
		  treeP->ages[treeIdx],     // node age
		  PSTATE.factors[treeIdx]   // factor at the beginning of the branch
		); 
  
  floating_t factorEnd = ret.factorEnd;
  floating_t accummulatedProbability = ret.prob;
     
  bool interiorNode = treeP->idxLeft[treeIdx] != -1 || treeP->idxRight[treeIdx] != -1;
  floating_t lnTerminalProb = interiorNode ? score_GammaExponential(0, PSTATE.lambda_0, factorEnd) : log(DATA_CONST(rho));
  
  WEIGHT(accummulatedProbability + lnTerminalProb);

  // Split simulation
  if(interiorNode) {
    // CRBD case
    floating_t f1 = 0.0;
    floating_t f2 = 0.0;

    if (CLADS) {
      f1 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma);
      f2 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma);
    }

    floating_t leftFactorEnd = factorEnd*exp(f1);
    floating_t rightFactorEnd = factorEnd*exp(f2);
    
    PSTATE.factors[treeP->idxLeft[treeIdx]] = leftFactorEnd;
    PSTATE.factors[treeP->idxRight[treeIdx]] = rightFactorEnd;
  } 
})


/*
 * simCombineDS - required BBLOCK
 */
BBLOCK(simCombineDS,
{
  // Set up tree traversal
  tree_t* treeP = DATA_POINTER(tree);
  PSTATE.treeIdx = treeP->idxLeft[ROOT_IDX];
    
  // Correction factor
  int numLeaves = countLeaves(treeP->idxLeft, treeP->idxRight, treeP->NUM_NODES);
  floating_t corrFactor = (numLeaves - 1) * log(2.0) - lnFactorial(numLeaves);
  WEIGHT(corrFactor);

  // CRBD case
  floating_t f1 = 0.0;
  floating_t f2 = 0.0;
  
  if (CLADS) {
    f1 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma);
    f2 = SAMPLE(sample_NormalInverseGammaNormal, PSTATE.alpha_sigma);
  }
  
  floating_t leftFactor = 1.0 * exp(f1);
  floating_t rightFactor = 1.0 * exp(f2);
    
  // The factors that are saved are the total accumulated factors
  PSTATE.factors[PSTATE.treeIdx] = leftFactor; // same as left of root, treeP->idxLeft[ROOT_IDX]
  PSTATE.factors[treeP->idxRight[ROOT_IDX]] = rightFactor;
      
  NEXT = simTree;
  BBLOCK_CALL(NEXT, NULL);
 })


/*
 * can be used on the GPU
 */
int adiscrete(const floating_t* ps, const int n) {
  //floating_t u = SAMPLE(uniform, 0, 1);    // replace this with c++ std library uniform
  //std::default_random_engine generator;
  std::random_device rd;
  std::mt19937 generator(rd());
  std::uniform_real_distribution<double> distribution(0.0,1.0);
  floating_t u = distribution(generator);
  floating_t sum = 0;    
  int idx = 0;    
  for(idx = 0; idx < n-1; idx++) {        
    sum += ps[idx];        
    if(u <= sum)            
      break;    
  }    
  return idx;
}
 

CALLBACK(saveResultsFile, {
    std::string headerFileName = "results/" + analysisName + "_header.csv";
    std::ofstream headerFile (headerFileName, std::ios_base::app);
    if (headerFile.is_open()) {
      //headerFile << "k, p, lambda_0.k, lambda_0.theta, mu_0.k, mu_0.theta, nu_0.k, nu_0.theta" << std::endl;
      headerFile << "lambda0, mu0, nu0, alpha, sigma2, alpha_nu, sigma_nu2, m0, b, m0_nu, b_nu" << std::endl;
      headerFile.close();
    }

    std::string resultsFileName = "results/" + analysisName + ".csv";
    std::ofstream resultsFile (resultsFileName, std::ios_base::app);
    if (resultsFile.is_open()) {
      floating_t maxWeight = WEIGHTS[0];
      for (int i = 1; i < N; i++) if (WEIGHTS[i] > maxWeight) maxWeight = WEIGHTS[i];
      
      /* Use the weights to choose the subsample in a numerically stable way. */
      floating_t probs[N]; 
      for (int i = 0; i < N; i++) probs[i] = exp(WEIGHTS[i] - maxWeight) ;
      
      for (int j = 0; j < M; j++) {
	//int k = SAMPLE(discrete, probs, N); doesn't work on GPU
	int k = adiscrete(probs, N);
	resultsFile << PSTATES[k].lambda0 << ", "
		    << PSTATES[k].mu0 << ", "
		    << PSTATES[k].nu0 << ", "
	            << PSTATES[k].alpha << ", "
		    << PSTATES[k].sigma << ", "
		    << PSTATES[k].alpha_nu << ", "
		    << PSTATES[k].sigma_nu << ", "
		    << PSTATES[k].alpha_sigma.m0 << ", "
   		    << PSTATES[k].alpha_sigma.b << ", "
		    << PSTATES[k].alpha_sigma_nu.m0 << ", "
    		    << PSTATES[k].alpha_sigma_nu.b <<
		    std::endl;

      }
      resultsFile.close();
    }
  })


BBLOCK(initialization, {
    // Priors
    PSTATE.lambda_0 = gamma_t(__(3)__, __(4)__);
    PSTATE.mu_0 = gamma_t(__(5)__, __(6)__);
    PSTATE.nu_0 = gamma_t(__(7)__, __(8)__);
    PSTATE.alpha_sigma = normalInverseGamma_t(__(9)__, __(10)__, __(11)__, __(12)__);
    PSTATE.alpha_sigma_nu = normalInverseGamma_t(__(13)__, __(14)__, __(15)__, __(16)__);
    
    NEXT = simCombineDS;
    BBLOCK_CALL(NEXT, NULL);
})


MAIN({
    FIRST_BBLOCK(initialization);
    //SMC(NULL)
    SMC(saveResultsFile);
})

